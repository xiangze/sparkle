/-
  VCD (Value Change Dump) Writer

  Generates VCD waveform files from Signal simulations for viewing in
  waveform viewers like GTKWave.

  VCD format reference: IEEE 1364-2001 Section 18
-/

import Sparkle.Core.Signal
import Sparkle.Core.Domain

namespace Sparkle.Backend.VCD

open Sparkle.Core.Signal
open Sparkle.Core.Domain

/-!
## VCD File Format

VCD files contain:
1. Header (date, version, timescale)
2. Scope and variable declarations
3. Initial values
4. Timestamped value changes

Example:
```
$date Thu Jan 30 2026 $end
$version Sparkle HDL $end
$timescale 1ns $end
$scope module top $end
$var wire 16 ! signal_name $end
$upscope $end
$enddefinitions $end
$dumpvars
b0000000000000000 !
$end
#0
#1
b0000000000001010 !
```
-/

/-- Signal identifier in VCD (!, ", #, $, etc.) -/
def makeIdentifier (idx : Nat) : String :=
  -- Use printable ASCII starting from '!'
  String.singleton (Char.ofNat (33 + idx))

/-- Convert BitVec to binary string for VCD -/
def bitVecToBinary (bv : BitVec n) : String :=
  -- Convert to binary by extracting bits
  let bits := List.range n |>.map fun i =>
    if bv.toNat >>> i &&& 1 == 1 then '1' else '0'
  String.ofList bits.reverse

/-- Convert Bool to VCD bit -/
def boolToVCD (b : Bool) : String :=
  if b then "1" else "0"

/-- VCD variable declaration -/
structure VCDVar where
  name : String
  identifier : String
  width : Nat
  deriving Repr, Inhabited

/-- VCD value at a specific time -/
inductive VCDValue where
  | bit : Bool → VCDValue
  | vector : BitVec n → VCDValue
  deriving Repr

/-- Format VCD value for output -/
def formatVCDValue (val : VCDValue) (id : String) : String :=
  match val with
  | .bit b => s!"{boolToVCD b}{id}"
  | .vector bv => s!"b{bitVecToBinary bv} {id}"

/-!
## VCD Writer State

Tracks variables and their values over time for VCD generation.
-/

structure VCDWriter where
  moduleName : String
  variables : List VCDVar
  timescale : String := "1ns"
  deriving Repr

/-- Create a new VCD writer -/
def VCDWriter.new (moduleName : String) : VCDWriter :=
  { moduleName := moduleName
    variables := []
    timescale := "1ns" }

/-- Add a variable to the VCD writer -/
def VCDWriter.addVar (writer : VCDWriter) (name : String) (width : Nat) : VCDWriter :=
  let idx := writer.variables.length
  let id := makeIdentifier idx
  let var : VCDVar := { name := name, identifier := id, width := width }
  { writer with variables := writer.variables ++ [var] }

/-!
## VCD Header Generation
-/

/-- Generate VCD header -/
def generateHeader (writer : VCDWriter) : String :=
  let date := "$date\n   Generated by Sparkle HDL\n$end\n"
  let version := "$version\n   Sparkle VCD Writer v1.0\n$end\n"
  let timescale := s!"$timescale {writer.timescale} $end\n"
  date ++ version ++ timescale

/-- Generate variable declarations -/
def generateVarDecls (writer : VCDWriter) : String :=
  let scope := s!"$scope module {writer.moduleName} $end\n"
  let vars := writer.variables.foldl (fun acc v =>
    acc ++ s!"$var wire {v.width} {v.identifier} {v.name} $end\n"
  ) ""
  let upscope := "$upscope $end\n"
  let enddef := "$enddefinitions $end\n"
  scope ++ vars ++ upscope ++ enddef

/-!
## VCD Trace Generation

Generate timestamped value changes from Signal simulations.
-/

/-- Record of a signal value at a specific time -/
structure TraceEntry where
  time : Nat
  varId : String
  value : VCDValue
  deriving Repr

/-- Sample a BitVec signal over time -/
def sampleBitVecSignal {dom : DomainConfig} {n : Nat}
    (sig : Signal dom (BitVec n)) (varId : String) (cycles : Nat) : List TraceEntry :=
  List.range cycles |>.map fun t =>
    { time := t, varId := varId, value := .vector (sig.atTime t) }

/-- Sample a Bool signal over time -/
def sampleBoolSignal {dom : DomainConfig}
    (sig : Signal dom Bool) (varId : String) (cycles : Nat) : List TraceEntry :=
  List.range cycles |>.map fun t =>
    { time := t, varId := varId, value := .bit (sig.atTime t) }

/-- Generate initial value dump -/
def generateDumpVars (entries : List TraceEntry) : String :=
  let initialVals := entries.filter (·.time == 0)
  let vals := initialVals.foldl (fun acc e =>
    acc ++ formatVCDValue e.value e.varId ++ "\n"
  ) ""
  "$dumpvars\n" ++ vals ++ "$end\n"

/-- Group trace entries by time -/
def groupByTime (entries : List TraceEntry) : List (Nat × List TraceEntry) :=
  let times := entries.map (·.time) |>.eraseDups
  times.map fun t =>
    (t, entries.filter (·.time == t))

/-- Generate timestamped value changes -/
def generateTimeSteps (entries : List TraceEntry) : String :=
  let grouped := groupByTime entries
  grouped.foldl (fun acc (t, vals) =>
    let timestamp := s!"#{t}\n"
    let changes := vals.foldl (fun vacc e =>
      vacc ++ formatVCDValue e.value e.varId ++ "\n"
    ) ""
    acc ++ timestamp ++ changes
  ) ""

/-!
## High-Level VCD Generation API
-/

/-- Generate complete VCD file from trace entries -/
def generateVCD (writer : VCDWriter) (entries : List TraceEntry) : String :=
  generateHeader writer ++
  generateVarDecls writer ++
  generateDumpVars entries ++
  generateTimeSteps entries

/-- Write VCD file to disk -/
def writeVCDFile (filename : String) (content : String) : IO Unit := do
  IO.FS.writeFile filename content
  IO.println s!"VCD file written to: {filename}"

end Sparkle.Backend.VCD
